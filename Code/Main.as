/**
 *
 * 								------------------
 * 								 《游戏框架示例》
 * 								------------------
 *
 *
 * 		作者：			陳局長
 * 		所属团队：		试刀游戏(R)
 * 		开发完整代号：	com.stickgames.projects.tdgameframe
 * 		开工日期：		2015/12/30
 * 		初步完成日期：	2016/1/6
 * 		最后更新日期：	2016/5/15
 * 		注释更新日期：	2016/6/27
 * 		版本：			3.5.2
 *
 * 【特别注意：	本框架及源代码均仅供试刀游戏内部研究和学习使用，未经许可请勿
 * 	随意传播或用作商业用途！】
 *
 * 	=========================
 *
 * 		在局长经过数个月努力研究皇家守卫军的文件中的源代码，学习游戏关卡的构
 * 	建思路以后，局长精心编制了这个游戏框架，用于表现塔防游戏关卡的实现思路和
 * 	原理，并可供试刀游戏团队中有意学习编程的同学参考。
 *
 * 		本框架只实现了最最基础的内容，即关卡部分，并且没有界面的美化及动画效
 * 	果。在以后的版本中可能会添加其它类型的塔台、游戏地图或天赋等等，取决于局
 * 	长未来的研究成果及群内的呼声。
 *
 * 		在框架的编制当中，局长使用纯面向对象的程序设计来编程。最初只是作为尝
 * 	试，也没想过成功了。成功以后，局长为代码添加了必要的注释，希望大家在研究
 * 	的时候更容易阅读和理解。添加的注释主要有类中功能代码块的分割，以及方法、
 * 	属性及存取器的解释。使用 FlashDevelop (可在试刀游戏群文件中下载) 软件可
 * 	以很轻松地编写代码或查看注释，将鼠标移到想查看注释的方法或属性上就可以看
 * 	到对于它的说明了，并且通过右键单击 ---> “跳转到声明处”更可以快速的转到它
 * 	的定义的地方，这样也可以看到方法的实现原理。
 *
 * 													2016 年 1 月 16 日
 *
 *  =========================
 *
 * 		此处用于写类的中文说明。在说明中会出现一些特殊的类的解释（标记），主
 * 	要有以下几种：
 *
 * 		[抽象基类] 代表该类为抽象基类。关于抽象基类的解释在文档类上方。
 *
 * 		[动态] 代表该类为动态类。不提倡使用动态类，因为在进行属性或类型检查
 * 	时会变的过于宽松，因此只有某些基类使用为动态类。
 *
 * 		[尚未使用] 此类、方法或属性只是声明了，全局并没有使用到。这可能是以后
 * 	将要更新的内容。
 *
 * 	=========================
 *
 * 	更新日志：
 *
 * 		[注] 更新编号说明：
 *
 * 			更新版本号一般表现为形如“1.2.3”的格式。“1”处表示为重大功能性的模块
 * 		更新；“2”处表示一般功能的更新；“3”处表示小修改，包括细节优化等。
 *
 * 	更新日志请参看“GameVersion”类文件。
 *
 */
package
{
	
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	IMPORTS / 导入
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
	
	/**
	 * 		此处主要用于引用包和类，使用了外部的包和类必须导入进来。在导入时
	 * 	FlashDevelop 软件会自动地按照字母顺序来导入，变得更加灵活和方便。
	 */
	import com.stickgames.SGAnimator;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.events.MouseEvent;
	import flash.utils.getTimer;
	
	public class Main extends Sprite
	{
		
		/// /// /// /// ///
		///    STATIC   ///
		/// /// /// /// ///
		
		/**
		 * 		STATIC 为静态内容，即属性或方法属于类，而不属于实例。
		 * 	使用静态内容不需要实例化类，直接使用“类名.属性/方法”就能
		 * 	访问到相应的内容。一般来说，常量都是静态的，静态常量可以
		 * 	用来制作相应的属性值的枚举，比如“MouseEvent.CLICK”就是一
		 * 	种鼠标事件的 type 属性值的枚举。
		 *
		 * 		静态内容也有自己的缺点，就是访问效率太低。因此，局长
		 * 	不提倡使用静态变量来作为临时传值的桥梁，而是采用了一大串
		 * 	路径的形式，这样即使不符合某些游戏开发标准，但可以带来效
		 * 	率上的好处。至于说到底应不应该使用静态变量作为桥梁，也可
		 * 	以群内商定后再做决定。
		 *
		 * 		静态的属性或方法的注释前会有“[静态]”标识。
		 */
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	STATIC_PROPERTIES_AND_ACCESSORS / 静态属性和存取器
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
		
		/**
		 * 		此处为静态属性，主要包括静态常量或私有的静态变量。静态常量
		 * 	可用作值的枚举，私有静态变量可以配合存取器或相应的方法形成一个
		 * 	全局控件，方便程序的各地使用而无需生成类的实例。著名的
		 * 	SoundManager 声音控制类就采用了这种管理模式。有兴趣的同学可以
		 * 	百度一下。
		 */
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	STATIC_METHODS / 静态方法
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
		
		/**
		 * 		此处为静态方法。静态方法可以和私有静态变量搭配形成全局控件，
		 * 	也可以实现某种判断性质的特殊功能。在该框架中的 GameSettings 游
		 * 	戏配置类中用到了静态方法，参考它们也可以大致理解静态方法充当的
		 * 	效果。
		 */
		
		/// /// /// /// ///
		///   INSTANCE	///
		/// /// /// /// ///
		
		/**
		 * 		INSTANCE 为实例内容，即必须实例化该类的属性之后可以使用的内容。
		 * 	使用“new + 构造函数”的形式可以实例化一个类。
		 */
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	CONSTRUCTOR / 构造函数
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
		/**
		 * 		构造函数是一个类在被实例化之后首先执行的代码，因此它可以被看做赋
		 * 	值类的初始化过程。
		 *
		 * 		这地方专门用来写构造函数的说明。构造函数的说明主要有两种，一种是
		 * 	创建新的类对象，另一种是该类为抽象基类，最好不要进行实例化。
		 *
		 * 		对于抽象基类，主要是学习了 AS3 中的一种编程的思想，对于有共同点的
		 * 	类，把它们的共同方法或属性提取出来写成一个类，这样有新的功能可以很方
		 * 	便地覆盖掉，从而达到提炼精华的效果，这可以增加编程的效率，代码写起来
		 * 	也更加舒服。由于抽象基类并没有和 FLA 库中的对象进行绑定，所以实例化
		 * 	之后看不到效果，也容易出错，这就是为什么不推荐实例化抽象基类，而是实
		 * 	例化它的子类。
		 *
		 * 		下面给出了一个使用抽象基类的例子。
		 *
		 * 		class 人 {
		 * 			function 吃() {
		 * 				吃（不同点）
		 * 			}
		 * 			function 玩() {
		 * 				玩（共同点）
		 * 			}
		 * 		}
		 *
		 * 		class 中国人 extends 人 {
		 * 			override function 吃() {
		 * 				使用筷子
		 * 			}
		 * 		}
		 *
		 * 		class 美国人 extends 人 {
		 * 			override function 吃() {
		 * 				使用叉子
		 * 			}
		 * 		}
		 *
		 * 		由此可以看到，“玩”是相同点，在基类中写好，
		 * 	将不同点单独覆盖掉就好。
		 *
		 */
		public function Main()
		{
			super();
			
			this.addEventListener(Event.ADDED_TO_STAGE, this.init, false, 0, true);
		}
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	PROPERTIES / 属性
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
		/**
		 * 		这地方是属性的说明。属性有公有和私有两种。一般来说，面向对象编程
		 * 	的原则应该全是私有属性（字段），再采用公有的存取器方法来供外部读取和
		 * 	写入，这样体现了类的封装，也能更好地控制传入和传出的值，便于在传值的
		 * 	过程中做一些其它的操作，符合面向对象的思想。
		 *
		 * 		但是存取器有一个很大的弱点，那就是运行的效率很低，使用“私有属性+
		 * 	存取器”的模式，与直接采用“公有属性”相比，运行时间增加近十倍。由于效
		 * 	率过低，再加上目前局长是一个人开发，局长自己了解哪些变量不应该修改，
		 * 	所以不到必要的时候局长还是避免存取器的使用。对于存取器的用法，请参看
		 * 	下面“属性存取器”模块。
		 */
		
		/**
		 * 全局游戏控制总对象。
		 */
		public var game:Game;
		
		/**
		 * 试刀游戏开场动画。
		 */
		public var sgAnim:SGAnimator;
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	ACCESSORS / 属性存取器
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
		/**
		 * 		此处为属性的存取器。存取器是一类特殊的函数，声明起来像方法，使用
		 * 	起来像属性。属性分为 Getter（读取器）和 Setter （设置器），搭配私有
		 * 	变量可以做成只读或只写属性。
		 *
		 * 		private var _日期:int;
		 *
		 * 	一个日期变量，习惯上前面加上下划线表示私有变量。现在我们来创建一个
		 * 	变量的 Getter 读取器。
		 *
		 * 		public function get 日期():int {
		 * 			return _日期;
		 * 		}
		 *
		 * 	这样就创建好了一个只读属性。只读属性注释前会有“[只读]”标记。
		 *
		 * 		利用 Setter 可以创建属性的设置器。
		 *
		 * 		由于我们知道日期只能在 1 至 31 范围内取值，因此我们可以创建一个
		 * 	带判断的设置器了。
		 *
		 * 		public function set 日期(x:int) {
		 * 			if (x < 1 || x > 31)
		 * 				throw new Error("输入的日期无效！！");
		 * 			_日期 = x;
		 * 		}
		 *
		 * 		只写属性注释前带有“[只写]”标记。
		 *
		 * 		既能读、也能写的就是读写属性。用类似访问属性的格式就可以使用存
		 * 	取器了，也就是形如“日期 = 1”这样。
		 */
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	INITIALIZATION / 初始化
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
		
		/**
		 * 		局长在编程上有一种习惯，一个类专门有一个模块进行类的初始化，而非
		 * 	直接使用构造函数，这个模块一般搭配 ADDED_TO_STAGE 事件进行使用，即侦
		 * 	听对象被添加到了舞台上。这样有三点好处：一是避免了对象没被添加到舞台，
		 * 	父级对象或舞台访问为空对象带来的一些问题，二是这样一个类就可以进行再
		 * 	次初始化或由外部使其初始化，三是方便子类的覆盖。具体是否应该使用单独
		 * 	的模块来初始化一个类，也可以讨论之后再做决定。
		 */
		protected function init(event:Event):void
		{
			this.removeEventListener(Event.ADDED_TO_STAGE, this.init);
			
			//this.playSGAnim();
			this.startGame();
			
			//trace("time name dead act idle fight block findtargetnote");
			
			//this.addEventListener(Event.ENTER_FRAME, this.onFrameUpdate, false, 0, true);
			this.stage.addEventListener(MouseEvent.RIGHT_MOUSE_DOWN, new Function(), false, -1); //添加鼠标右键按下的事件侦听可以巧妙地禁止右键菜单的出现。
		}
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	METHODS / 方法
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
		/**
		 * 		方法即实例的函数，专门实现一种特定的功能。对于方法局长想也不需要
		 * 	多说了。
		 */
		
		/**
		 * 播放试刀游戏特色开场动画。
		 */
		public function playSGAnim():void
		{
			this.sgAnim = new SGAnimator();
			this.addChildAt(this.sgAnim, 0);
			
			this.sgAnim.start();
			
			this.sgAnim.addEventListener(Event.COMPLETE, this.onSGAnimComplete, false, 1, true);
		}
		
		/**
		 * 开始运行全局游戏。
		 */
		public function startGame():void
		{
			this.game = new Game();
			
			this.addChildAt(this.game, 0);
		}
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	FRAME_UPDATER / 帧更新器
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
		
		/**
		 * 		更新器主要用于配合 ENTER_FRAME 重复执行一段代码。由于在一个庞大的
		 * 	框架当中，显示对象太多，不可能给每一个对象都注册一个 ENTER_FRAME 的事
		 * 	件，因此采用一种解决方案，用一个顶级的对象注册该事件，再用 for 等循环
		 * 	语句遍历所有子显示对象，调用它们的更新器方法即可。
		 */
		/*protected function onFrameUpdate(event:Event):void
		   {
		   this["txt"] && (this["txt"].text = "time/s: " + int(getTimer() / 1000));
		   }*/
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	EVENT_HANDLERS / 事件侦听器
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		
		/**
		 * 		事件侦听器用于处理事件，一般声明为 protected 并放在代码的最后端。
		 * 	这是一种特殊的函数，大家也都已熟悉无需多说了。
		 */
		
		/**
		 * 试刀游戏开场动画播放完毕。
		 */
		protected function onSGAnimComplete(event:Event):void
		{
			this.sgAnim.removeEventListener(Event.COMPLETE, this.onSGAnimComplete);
			
			this.sgAnim.destroy();
			
			this.startGame();
			
			this.sgAnim = null;
		}
		
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
//	DESTROYER / 摧毁器
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
		
		/**
		 * 		实例化出类对象之后，它会占用相应的系统内存。如果在开发一个大
		 * 	作品对于这些不加注意，可能会造成内存溢出的严重问题，即用户的计算
		 * 	机的卡顿会随着程序的运行时间成正比！这时便只能关闭该程序再重新打
		 * 	开了。因此一定要时刻注意对象的释放。SWF 释放内存主要采用的是“垃圾
		 * 	回收器”的机制，当一个对象没有被引用时，系统便会自动消灭掉这个对象。
		 * 	因此局长在几乎每一个类的最后都会有一个摧毁器模块，专门用来移除对象，
		 * 	消除所有对对象的引用，不给这些实例蚕食内存的机会。
		 *
		 * 		上面这一段话对于类编程初学者来说可以略去不看，我们的局长 AS3
		 * 	教程中将会有专门的一章讲解程序优化。
		 */
		public function destroy():void
		{
			throw new Error("无法摧毁主文档类！！");
		}
	
	}
	// 倒数第二个大括号是类定义的结束。

}
// 最后一个大括号是包定义的结束。